<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb学习计划]]></title>
    <url>%2F2019%2F01%2F10%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[第一阶段 —— Web基础知识（HTML、CSS、JS、HTML5、CSS3）参考W3school进行学习。1.深入学习HTML5中canvas元素的使用。2.深入学习CSS3中动画模块（@keyframes规则）的使用以及在Internet Explorer 10、Firefox、Chrome、Safari、Opera五大主流浏览器中的兼容性。 第二阶段 —— Java基础知识和Java相关技术（Java、JSP、Servlet、Tomcat）参考全套Java基础视频教程进行学习。1.深入学习Java基础（包括面向对象、常用类、集合、IO、多线程等）。2.深入学习Servlet和Tomcat的使用。 第三阶段 —— Web相关技术（AJAX、JSON、Git）参考W3school和CSDN进行学习。1.深入学习AJAX的高级用法AJAX与ASP/PHP、AJAX与数据库、AJAX与XML。2.深入学习Git的基本命令。 第四阶段 —— 数据库基础知识（Oracle、MySQL）1.深入学习SQL语句，达到对数据库的增、删、改、查。 第五阶段 —— JS常用组件库及前端框架（JQuery、bootstrap、Vue.js）参考jQuery官方文档、bootstrap官方文档、Vue.js官方文档进行学习。第六阶段 —— CSS预处理器、JS新特性和前端模块打包工具（Less、Sass、ES6、webpack）参考Less官方文档、Sass官方文档、ES6官方文档、webpack官方文档进行学习。第七阶段 —— 虚拟机（Linux、Shell）参考Linux官方文档进行学习。第八阶段 —— 扩展学习1.了解安卓和IOS的兼容性。2.了解各大主流浏览器的兼容性。3.了解HTTP、TCP/IP服务协议。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue全家桶介绍]]></title>
    <url>%2F2019%2F01%2F04%2F1_title1%2F</url>
    <content type="text"><![CDATA[Vue有著名的全家桶系列，包含了vue-router（http://router.vuejs.org），vuex（http://vuex.vuejs.org）， vue-resource（https://github.com/pagekit/vue-resource）。再加上构建工具vue-cli，sass样式,就是一个完整的vue项目的核心构成。 概括起来就是：、1.项目构建工具、2.路由管理器、3.状态管理模式、4.http请求工具。 vue-cli——脚手架（项目构建工具）12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖$ cd my-project$ npm install$ npm run dev vue-router——路由管理器vue-router是一个插件包，需要用npm来进行安装的。如果采用vue-cli构建初始化项目会提示安装，也可以自己使用命令安装： 1npm installvue-router 用vue-cli构建项目之后，在src/router/index.js文件中，看到以下的路由核心文件： 1234567891011121314151617181920// 引入vue框架import Vue from &apos;vue&apos;// 引入vue-router路由依赖import Router from &apos;vue-router&apos;// 引入页面组件，命名为HelloWorldimport HelloWorld from &apos;@/components/HelloWorld&apos;// Vue全局使用RouterVue.use(Router)// 定义路由配置export default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: &apos;/&apos;, //链接路径 name: &apos;HelloWorld&apos;, //路由名称， component: HelloWorld //对应的组件模板 &#125; ]&#125;) 在系统入口文件main.js中注入router，代码如下： 1234567891011121314151617// 引入vue框架import Vue from &apos;vue&apos;// 引入根组件import App from &apos;./App&apos;// 引入路由配置import router from &apos;./router&apos;// 关闭生产模式下给出的提示Vue.config.productionTip = false// 定义实例new Vue(&#123; el: &apos;#app&apos;, router, // 注入框架中 components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) vuex——状态管理模式Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。如前面所提到的，Vuex 已经集成到 Vue 的官方调试工具vue Devtools，可以轻松的查看项目中的Vuex状态变化情况。 假设有这样一个场景：我们的项目规模比较大，有多个父组件，每个父组件同时又包含多个子组件。如何保持对所有时间的追踪将变得很困难。到底哪个事件是哪个组件派发的，哪个组件该监听哪个事件？父组件将变得和子组件耦合越来越严重，因为它需要明确的派发和监听子组件的某些事件。项目逻辑分散在各个组件当中，很容易导致逻辑的混乱，不利于我们项目的维护。 这就是 Vuex 用来解决的问题。 Vuex 的四个核心概念分别是： The state tree：Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(SSOT)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 Getters：用来从 store 获取 Vue 组件数据。 Mutators：事件处理器用来驱动状态的变化。 Actions：可以给组件使用的函数，以此用来驱动事件处理器 mutations Vuex和简单的全局对象是不同的，当Vuex从store中读取状态值的时候，若状态发生了变化，那么相应的组件也会高效的更新。并且，改变store中状态的唯一途径就是提交commit mutations。这样便于我们跟踪每一次状态的变化。只要发生了状态的变化，一定伴随着mutation的提交。 vue-resource——http请求工具Vue-resource主要用于发送ajax请求,官网已经不在维护(推荐axios)。 Vue-resource有体积小，支持IE9以上的浏览器，支持promise特性的特点。同样推荐使用npm来安装Vue-resource。 1$ npm install vue-resource 在安装并引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。 在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。 vue-resource的请求API是按照REST风格设计的，它提供了7种请求API： get(url,[options]) head(url,[options]) delete(url,[options]) jsonp(url,[options]) post(url,[body], [options]) put(url, [body],[options]) patch(url,[body], [options]) axios——http请求工具axios是一个http请求包，vue官网推荐使用axios进行http调用。 12# 安装$ npm install axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。简单来说就是前端最火最简单的一个http请求解决方案。 功能： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF]]></content>
      <categories>
        <category>学习</category>
        <category>前端框架</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
        <tag>vuex</tag>
        <tag>vue-resource</tag>
        <tag>vue-cli</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见 2018丨你好 2019]]></title>
    <url>%2F2018%2F12%2F31%2F2018-2019%2F</url>
    <content type="text"><![CDATA[过了今天，2018就将结束。回首这一年，有欢笑也有泪水，有收获也有遗憾。或许没有容易的人生，却有不言放弃的你我。感谢自己这一年来的成长，也为新的一年定下小目标。 再见，2018；你好，2019。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown使用指南]]></title>
    <url>%2F2018%2F12%2F31%2Ftitle13%2F</url>
    <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 用于编写说明文档，并且以“README.MD”的文件名保存在软件的目录下面。 除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。 1.常用语法最常见的Markdown格式选项和键盘快捷键： 输出后的效果 Markdown 快捷键 Bold **text** Ctrl/⌘ + B Emphasize *text* Ctrl/⌘ + I Link [title](http://) Ctrl/⌘ + K Inline Code ´code´ Ctrl/⌘ + Shift + K Image ![alt](http://) Ctrl/⌘ + Shift + I List * item Ctrl + L Blockquote &gt; quote Ctrl + Q H1 # Heading H2 ## Heading Ctrl/⌘ + H H3 ### Heading Ctrl/⌘ + H (x2) 2.标题标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。 H1 :# Header 1 H2 :## Header 2 H3 :### Header 3 H4 :#### Header 4 H5 :##### Header 5 H6 :###### Header 6 3.文本样式（带“*”星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加） 链接 :[Title](URL) 加粗 :**Bold** 斜体字 :*Italics* *高亮 :==text== 段落 :段落之间空一行 换行符 :一行结束时输入两个空格 列表 :* 添加星号成为一个新的列表项 引用 :&gt; 引用内容 内嵌代码 :´alert(&#39;Hello World&#39;);´ 画水平线 (HR) :-------- 方框：- [ ] - 4.图片用Markdown将图像插入文章，你需要在Markdown编辑器输入 ![]() 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的“链接”图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号，e.g;![This is a title](). 5.脚注脚注不存在于标准Markdown中。 使用这样的占位符号可以将脚注添加到文本中:[^1]. 另外，你可以使用“n”而不是数字的[^n]所以你可以不必担心使用哪个号码。在您的文章的结尾，你可以如下图所示定义匹配的注脚，URL将变成链接: 12345这里是脚注[^1][^1]: 这里是脚注的内容 这里是脚注[^n][^n]: 这里是脚注的内容 6.写代码添加内嵌代码可以使用一对回勾号 ´alert(&#39;Hello World&#39;)´.对于插入代码, Ghost支持标准的Markdown代码和GitHub Flavored Markdown (GFM) 。标准Markdown基于缩进代码行或者4个空格位: 1234示例: &lt;header&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/header&gt; GFM 使用三个回勾号´´´ 12345´´´&lt;header&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/header&gt;´´´ 7.编辑器常用的Markdown 编辑器 OSXVSCodeAtomBywordMouTyporaMacDownRStudio LinuxVSCodeAtomTyporaReTextUberWriterRStudio WindowsVSCodeAtomCuteMarkEdMarkdownPad2MiuTyporaRStudio iOSByword 浏览器插件MaDo (Chrome)Marxico（Chrome） 高级应用Sublime Text 3 + MarkdownEditing / 教程 8.Markdown添加空格效果 在中文输入法下使用全角 在中文输入法的情况下：ｓｈｉｆｔ＋空格键切换至全角模式， 之后再按空格键，那么空格键就会生效。 添加代码 添加&amp;#160;或者&amp;nbsp; 注意：分号是英文状态下的！]]></content>
      <categories>
        <category>学习</category>
        <category>编辑器</category>
        <category>MarkdownPad2</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>markdownpad2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js新手入门指南]]></title>
    <url>%2F2018%2F12%2F31%2Ftitle12%2F</url>
    <content type="text"><![CDATA[1.Vue.js是什么？ Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。 这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？ 接下来将进行详细的介绍。 2.单页应用程序（SPA）顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。 3.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。 现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。 我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。 Vue 的核心库只关注视图层 我们为什么要把视图层抽取出来并且单独去关注它呢？ 因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？ 你是否还记得你当初写JQuery的时候，有写过$(‘#xxx’).parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么$(‘#xxx’).parent().parent().parent()可能就会变成$(‘#xxx’).parent().parent().parent().parent().parent()了。 这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。 当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。 这个时候如果你学过Vue.js，那么这些抱怨将不复存在。 4.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。 可是这些名词都是啥？ 5.响应式的数据绑定这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js测试&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; placeholder=&quot;在这里输入文字，下面会跟着变化&quot; v-model=&quot;message&quot;&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 是不是会发现一个很神奇的现象，文本框里面输入的文字和后面的p标签中的内容一起变化？ 换句话说，p标签里面通过这个写法与input标签中的value绑定在了一起，其中变化，另外一个和它绑定的数据就跟着变化。 结合标题来说，就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。 6.组件化开发还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说PHP的Smarty或者Java的JSP等等。 但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。 在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。 在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。 Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。 7.Virtual DOM现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。 而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。 对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。 8.我到底该怎么用Vue.js做单页应用开发？说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？ 前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？ 我的建议是，先把介绍 - vue.js官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。 然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。 最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。 9.在前面你提到过好几次ECMAScript，这是啥？ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？ 没错你猜对了，他们之间还真有着很深的联系。 引用阮一峰老师的话：（ECMAScript 6入门） 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。 该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 而ECMAScript6就是新一代的JavaScript语言。 这里也强烈推荐大家学习ECMAScript6的时候参考这本书ECMAScript 6入门 10.我在学习Vue.js的时候老是听到Webpack，这是啥？Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。 11.为什么要用Webpack前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？ 还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。 前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6 to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。 开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中 当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。 12.NPM和Node.js又是什么？它们是什么关系？首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。 NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过 1npm install xxx包名称 的方式引入它，比如说1npm install vue 就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。 至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。 前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。 如果你学过PHP的话，NPM就和PHP里面的Composer差不多。也和CentOS下的yum和Ubuntu下的apt-get差不多。 13.Vue-CLi又是啥？它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过 1npm install vue-cli -g 的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。 14.Vue.js怎么火起来的？前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。 对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。 而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。 当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。 15.我在很多地方还看到Vuex和Vue-route，它们又是什么？Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。 Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。 要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。 16.我还在一些地方看到过Vue-resource和Axios，它们又是什么？我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。 在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。 vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。]]></content>
      <categories>
        <category>学习</category>
        <category>前端框架</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令笔记]]></title>
    <url>%2F2018%2F12%2F29%2Ftitle11%2F</url>
    <content type="text"><![CDATA[git基本命令1.git常用命令一般配置123git --version //查看git的版本信息git config --global user.name //获取当前登录的用户git config --global user.email //获取当前登录用户的邮箱 登录git1234/* 如果刚没有获取到用户配置，则只能拉取代码，不能修改 要是使用git，你要告诉git是谁在使用*/git config --global user.name &apos;userName&apos; //设置git账户，userName为你的git账号git config --global user.email &apos;email&apos; //email为你的邮箱地址 创建一个文件夹12mkdir nodejs //创建文件夹nodejscd nodejs //切换到nodejs目录下 初始化git仓库1git init //在nodejs文件夹下初始化一个仓库，此时文件里会到一个.git的隐藏文件夹 创建忽略文件12345touch .gitignore //不需要服务器端提交的内容可以写到忽略文件里 /* .git .idea */ 查看目录1ls -al 创建文件并写入内容如果文件不存在则会创建文件 12echo &quot;hello git&quot; &gt; index.html //将&apos;hello git&apos; 写入到index.html中 单个&gt;箭头表示写入， &gt;&gt;表示追加 查看文件内容1cat index.html 增加到暂存区中12git add index.htmlgit add -A //全部添加到缓存区 增加到版本库中1git commit -m &apos;备注信息&apos; 查看版本1git log --oneline 比较差异比较的是暂存区和工作区的差异 1git diff 比较的是暂存区和历史区的差异 1git diff --cached 比较的是历史区和工作区的差异（修改） 1git diff master 撤回内容(如果修改了工作区的文件后发现改错了，可以用暂存区或者版本库里的文件替换掉工作区的文件) 用暂存区中的内容或者版本库中的内容覆盖掉工作区 1git checkout index.html 取消增加到暂存区的内容（添加时） 123git reset HEAD index.html//显示目录的状体 有没有添加或者修改文件git status 删除本地文件1rm fileName 删除暂存区保证当前工作区中没有index.html 1git rm index.html --cached 使用–cached 表示只删除缓存区中的内容 回滚版本回滚最近的一个版本 git log 1git reset --hard HEAD/commit_id 回滚到未来1git reflog 2.分支管理创建分支1git branch dev 切换分支1git checkout dev 创建分支并切换分支1git checkout -b dev 删除分支1git branch -d dev 在分支上提交新的版本1git commit -a -m &apos;dev1&apos; 合并分支1git merge dev 分支的合并后显示log1git log --oneline --graph --decorate 在分支开发的过程中遇到其他问题需要切换其他分支保留写好的内容在切换到主干 保留内容 1git stash 在次切换分之后需要应用一下保留的内容1git stash apply 丢掉保存的内容1git stash drop 使用并丢掉1git stash pop 最佳分支有的时候开发需要合并指定的内容，而不是合并所有的提交，所以我们需要挑选最好的，自己生产版本。 合并分支把树杈掰到主干上1git rebase 3.添加远程的仓库push -u-u参数 upstream 1git push origin master -u //获取最新代码 连接远程仓库1git remote add origin 仓库的地址 查看远程仓库1git remote -v 删除远程仓库1git remote rm origin 4.git常用命令安装及配置：Ubuntu下安装：sudo apt-get install git配置用户名：git config –global user.name “你的名字”配置e-mail：git config –global user.email “你的邮箱@xx.com” 与添加有关的：将当前目录变为仓库：git init将文件添加到暂存区：git add 文件名 [可选：另一个文件名]将暂存区提交到仓库：git commit –m “描述” 与查询有关的：查询仓库状态：git status比较文件差异（请在git add之前使用）：git diff 文件名查看仓库历史记录(详细)：git log查看仓库历史记录(单行)：git log –pretty=online 或 git log –online查看所有版本的commit ID：git reflog 与撤销有关的：撤销工作区的修改：git checkout – 文件名撤销暂存区的修改：git reset HEAD 文件名回退到历史版本：git reset –hard 该版本ID回退到上个版本：git reset –hard HEAD^上上版本是HEAD^^，也可用HEAD~2表示，以此类推 与标签有关的：为当前版本打标签：git tag 标签名为历史版本打标签：git tag 标签名 该版本ID指定标签说明：git tag –a 标签名 –m “标签说明” [可选：版本ID]查看所有标签：git tag查看某一标签：git show 标签名删除某一标签：git tag –d 标签名 与GitHub有关的：先有本地库，后有远程库，将本地库push到远程库关联本地仓库和GitHub库：git remote add origin 网站上的仓库地址第一次将本地仓库推送到GitHub上：git push –u origin master 先有远程库，后有本地库，从远程库clone到本地库从远程库克隆到本地：git clone 网站上的仓库地址 网站地址可以选择HTTPS协议（https://github.com...）、SSH协议（git@github.com...）。如果选择SSH协议，必须将Ubuntu的公钥添加到GitHub上。见下一步 SSH Key生成SSH Key：ssh-keygen –t rsa –C “你的邮箱@xx.com”生成Key时弹出选项，回车选择默认即可。Key保存位置：/root/.ssh登陆GitHub，创建new SSH key，其内容为/root/.ssh/id_rsa.pub中文本 已经有了本地库和远程库，二者实现同步本地库的改动提交到远程库：git push origin master更新本地库至远程库的最新改动：git pull]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>git和github</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git和github]]></title>
    <url>%2F2018%2F12%2F29%2Ftitle10%2F</url>
    <content type="text"><![CDATA[一、什么是git和github？1.GIT（分布式版本控制系统）对于分布式版本控制系统，每个用户中都有自己在本地的仓库用来管理版本控制，每个客户端也同时是一个服务器。同时也可以用一个专门的服务器的仓库用来管理。 分布式版本控制系统的不同用户之间，只要是在同一个局域网都是想通的，入上图所示。所以某一个用户协同工作的服务器发生故障，并不会影响到整个团队。 与集中式版本控制系统相比： 1) 分布式版本控制系统更安全，因为每个客户端都是一个服务器，拥有一个完整地版本库，包括所有的历史记录等； 2) 工作效率会更高，因为对于小的修改，用户可以先把新版本的文件提交到本地的仓库，本地提交的速度远远快于“远程”提交； 3) 如果是在同一个局域网，不同用户之间可以相互访问； 4) 对于非局域网协同工作的，可以创建一个连接互联网的的服务器仓库。 Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持，使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。 目前GIT已经可以在windows下使用，主要方法有二：msysgit和Cygwin。Cygwin和Linux使用方法类似，Windows版本的GIT提供了友好的GUI(图形界面)，安装后很快可以上手。 2.githubgitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 GitHub 使用 git 分布式版本控制系统，而 git 最初是 LinusTorvalds 为帮助Linux开发而创造的，它针对的是 Linux 平台，因此 git 和 Windows 从来不是最好的朋友，因为它一点也不像 Windows。GitHub 发布了GitHub for Windows，为 Windows 平台开发者提供了一个易于使用的 Git 图形客户端。 GitHub for Windows 是一个 Metro 风格应用程序，集成了自包含版本的 Git，bash 命令行 shell，PowerShell 的 posh-git 扩展。GitHub 为 Windows 用户提供了一个基本的图形前端去处理大部分常用版本控制任务，可以创建版本库，向本地版本库递交补丁，在本地和远程版本库之间同步。 二、git与github的区别一开始接触git或是github的程序员可能搞不太清楚这些名词到底指代的是什么，所以在这里稍微说明一下。git和github是两个完全不同的概念。 git是一个版本管理工具，是可以在你电脑不联网的情况下，只在本地使用的一个版本管理工具，其作用就是可以让你更好的管理你的程序，比如你原来提交过的内容，以后虽然修改了，但是通过git这个工具，可以把你原来提交的内容重现出来，这样对于你后来才意识到的一些错误的更改，可以进行还原，具体有关git的简介，我觉得有一个教程写的非常的详细，比较适合新手的学习，这是链接：Git教程 关于github，这是一个网站，就是每个程序员自己写的程序，可以在github上建立一个网上的仓库，你每次提交的时候可以把代码提交到网上，这样你的每次提交，别人也都可以看到你的代码，同时别人也可以帮你修改你的代码，这种开源的方式非常方便程序员之间的交流和学习。 github是一个非常适合程序员交流的网站，很多国际上的技术大牛都在github上有自己的开源代码，其他人只要申请个账号就可以随意的看到这些大牛写的程序。同时国内的很多互联网公司如百度，阿里等，也在github上公布有开源的代码，感兴趣的程序员也可以自己查找着看一些。 总结来说，git可以认为是一个软件，能够帮你更好的写程序，github则是一个网站，这个网站可以帮助程序员之间互相交流和学习。]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>git和github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理器（Sass、Less和Stylus）]]></title>
    <url>%2F2018%2F12%2F29%2Ftitle9%2F</url>
    <content type="text"><![CDATA[一、什么是Sass、Less和Stylus？Sass、Less和Stylus都属于CSS预处理器，那什么是 CSS 预处理器呢？ CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就 只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。 CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基 本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 CSS预处理器技术已经非常的成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、 Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、 CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。 到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将分别从他们产生的背 景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。 二、为什么要使用CSS预处理器？作为前端开发人员，大家都知道，Js中可以自定义变量，而CSS仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。 CSS有具体以下几个缺点： 1.语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；2.没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。 这就导致了我们在工作中无端增加了许多工作量。而使用CSS预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。 但是，CSS预处理器也不是万金油，CSS的好处在于简便、随时随地被使用和调试。预编译CSS步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。 所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS预处理器有没有解决更大的麻烦。 三、Sass、LESS和Stylus背景介绍为了能更好的了解这三款流行的CSS预处理器，我们先从其背景入手，简单的了解一下各自的背景信息。 1.Sass背景介绍Sass是对CSS（层叠样式表）的语法的一种扩充，诞生于2007年，最早也是最成熟的一款CSS预处理器语言，它可以使用变量、常量、嵌套、混 入、函数等功能，可以更有效有弹性的写出CSS。Sass最后还是会编译出合法的CSS让浏览器使用，也就是说它本身的语法并不太容易让浏览器识别，因为 它不是标准的CSS格式，在它的语法内部可以使用动态变量等，所以它更像一种极简单的动态语言。 其实现在的Sass已经有了两套语法规则：一个依旧是用缩进作为分隔符来区分代码块的；另一套规则和CSS一样采用了大括号（｛｝）作为分隔符。后一种语法规则又名SCSS，在Sass3之后的版本都支持这种语法规则。 注：Sass官网地址：http://sass-lang.com 2.LESS的背景介绍2009年开源的一个项目，受Sass的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手。LESS提供了多种方式能平滑的将写 好的代码转化成标准的CSS代码，在很多流行的框架和工具中已经能经常看到LESS的身影了（例如Twitter的Bootstrap框架就使用了 LESS）。 根据维基百科上的介绍，其实LESS是Alexis Sellier受Sass的影响创建的一个开源项目。当时SASS采用了缩进作为分隔符来区分代码块，而不是CSS中广为使用的大括号（｛｝）。为了让 CSS现有的用户使用起来更佳方便，Alexis开发了LESS并提供了类似CSS的书写功能。 注：LESS的官网：http://lesscss.org 3.Stylus背景介绍Stylus，2010年产生，来自于Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如Sass和LESS。 Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。 注：Stylus官网：http://learnboost.github.com/stylus 四、Sass和Less的比较不同之处1.Less环境较Sass简单Cass的安装需要安装Ruby环境，Less基于JavaScript，是需要引入Less.js来处理代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放在项目中，有less.app、SimpleLess、CodeKit.app这样的工具，也有在线编辑地址。 2、Less使用较Sass简单LESS 并没有裁剪 CSS 原有的特性，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。只要你了解 CSS 基础就可以很容易上手。 3、从功能出发，Sass较Less略强大一些(1) sass有变量和作用域 $variable，like php； #｛$variable｝like ruby； 变量有全局和局部之分，并且有优先级。 (2) sass有函数的概念 @function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。 @mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。 ruby提供了非常丰富的内置原生api。 (3) 进程控制 条件：@if @else； 循环遍历：@for @each @while 继承：@extend 引用：@import (4) 数据结构 $list类型=数组； $map类型=object；其余的也有string、number、function等类型 4、Less与Sass处理机制不一样前者是通过客户端处理的，后者是通过服务端处理，相比较之下前者解析会比后者慢一点。 5、关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。相同之处Less和Sass在语法上有些共性，比如下面这些： 1、混入(Mixins)——class中的class；2、参数混入——可以传递参数的class，就像函数一样；3、嵌套规则——Class中嵌套class，从而减少重复的代码；4、运算——CSS中用上数学；5、颜色功能——可以编辑颜色；6、名字空间(namespace)——分组样式，从而可以被调用；7、作用域——局部修改样式；8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。 五、为什么选择使用Sass而不是Less？1、Sass在市面上有一些成熟的框架，比如说Compass，而且有很多框架也在使用Sass，比如说Foundation。2、就国外讨论的热度来说，Sass绝对优于LESS。3、就学习教程来说，Sass的教程要优于LESS。在国内LESS集中的教程是LESS中文官网，而Sass的中文教程，慢慢在国内也较为普遍。4、Sass也是成熟的CSS预处理器之一，而且有一个稳定，强大的团队在维护。5、同时还有Scss对sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。6、bootstrap（Web框架）最新推出的版本4，使用的就是Sass。]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Sass</tag>
        <tag>Less</tag>
        <tag>Stylus</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3属性笔记]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle8%2F</url>
    <content type="text"><![CDATA[新的边框属性 属性 描述 CSS border-image 设置所有 border-image-* 属性的简写属性。 3 border-radius 设置所有四个 border-*-radius 属性的简写属性。 3 box-shadow 向方框添加一个或多个阴影。 3 新的背景属性 属性 描述 CSS background-clip 规定背景的绘制区域。 3 background-origin 规定背景图片的定位区域。 3 background-size 规定背景图片的尺寸。 3 新的文本属性 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 CSS3 字体描述符下面的表格列出了能够在 @font-face 规则中定义的所有字体描述符： 描述符 值 描述 font-family name 必需。规定字体的名称。 src URL 必需。定义字体文件的 URL。 font-stretch normal condensed ultra-condensed extra-condensed semi-condensed expanded semi-expanded extra-expanded ultra-expanded 可选。定义如何拉伸字体。默认是 “normal”。 font-style ormal italic oblique 可选。定义字体的样式。默认是 “normal”。 font-weight normal bold 可选。定义字体的粗细。默认是 “normal”。 unicode-range unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。 新的转换属性 属性 描述 CSS transform 向元素应用 2D 或 3D 转换。 3 transform-origin 允许你改变被转换元素的位置。 3 transform-style 规定被嵌套元素如何在 3D 空间中显示。 3 perspective 规定 3D 元素的透视效果。 3 perspective-origin 规定 3D 元素的底部位置。 3 backface-visibility 定义元素在不面对屏幕时是否可见。 3 过渡属性下面的表格列出了所有的转换属性： 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 CSS3 动画属性下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 animation-fill-mode 规定对象动画时间之外的状态。 3 3 新的多列属性下面的表格列出了所有的转换属性： 属性 描述 CSS column-count 规定元素应该被分隔的列数。 3 column-fill 规定如何填充列。 3 column-gap 规定列之间的间隔。 3 column-rule 设置所有 column-rule-* 属性的简写属性。 3 column-rule-color 规定列之间规则的颜色。 3 column-rule-style 规定列之间规则的样式。 3 column-rule-width 规定列之间规则的宽度。 3 column-span 规定元素应该横跨的列数。 3 column-width 规定列的宽度。 3 columns 规定设置 column-width 和 column-count 的简写属性。 3 新的用户界面属性下面的表格列出了所有的转换属性： 属性 描述 CSS appearance 允许您将元素设置为标准用户界面元素的外观 3 box-sizing 允许您以确切的方式定义适应某个区域的具体内容。 3 icon 为创作者提供使用图标化等价物来设置元素样式的能力。 3 nav-down 规定在使用 arrow-down 导航键时向何处导航。 3 nav-index 设置元素的 tab 键控制次序。 3 nav-left 规定在使用 arrow-left 导航键时向何处导航。 3 nav-right 规定在使用 arrow-right 导航键时向何处导航。 3 nav-up 规定在使用 arrow-up 导航键时向何处导航。 3 outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 3 resize 规定是否可由用户对元素的尺寸进行调整。 3]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语作文（1）]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle7%2F</url>
    <content type="text"><![CDATA[1.不要嘲笑别人的梦想 Don’t Laugh at Someone Else’ DreamsRecently, I saw an impressive story. A girl from America was laughed by her classmates, because she had a model dream. They told her that she was fat and looked homely, so it was impossible for her to be a model. The girl gave up going to school but she chose to study at home. She continued her passion for fashion, now she became a fashion blogger, and her followers were more than one million. What an inspiring story. Look at those people who laughed at her dream. They should be shameful on themselves. We should not laugh at someone else’s dream, no matter what kind of dreams they have. It is their motivation to move on and make progress. Most of them become somebody in the future if they insist on. The world becomes beautiful if we give support to each other. 最近，我看到一个令人印象深刻的故事。一个来自美国的女孩被同学嘲笑，因为她的梦想是当模特。他们告诉她，她很胖，而且看起来很平凡，所以这对她来说是不可能成为一名模特的。这个女孩放弃了上学，但她选择在家学习，也没有放弃对时尚的热情，现在她成为时尚博主，她的粉丝超过了一百万人。多么鼓舞人心的故事啊，看看那些嘲笑她梦想的人，他们应该感到羞耻。我们不应该嘲笑别人的梦想，无论他们的梦想是什么。这是他们前进和取得进步的动力。如果他们坚持的话，他们中的大多数人将来会成为有出息的人。如果我们相互支持世界会变得美好。 2.长时间玩游戏的后果 The Result of Playing Games For a Long TimeNowadays, young people like to play online games so much. Once they have time, they will take out their cellphones and then get addicted to it. So we can see people low down their heads everywhere, such as the bus station, the dinner table even they are walking down the street. How crazy it is. Though most people have been told the danger of playing games for hours, they still ignored it. Recently, a woman was reported to turn blind after playing online games for a long time. When she was sent to hospital, the doctor told her family they could do nothing to fix her eyes. What a great tragedy. At this young age, everybody can enjoy a happy life. We should take the regular exercise and keep the healthy lifestyle, stopping to play cellphone for hours. 如今，年轻人喜欢玩网络游戏，一旦他们有时间，就会拿出自己的手机，然后沉迷于玩游戏。所以我们可以随处看到人们低下头来，比如在公交车站，餐桌上甚至走在街上。这有多疯狂啊。大多数人虽然都被告知过长时间玩游戏的危害，但是他们仍然无视。最近，据报道，一名女子在玩了很长一段时间网络游戏后失明了，她被送到医院时，医生告诉她的家人，已经无法修复她的眼睛了。真是个悲剧。在这么小的年龄，每个人都应该享受快乐的生活，我们应该经常锻炼并保持健康的生活方式，停止长时间玩手机了。 3.信用的重要性 The Importance of CreditNowadays, with the development of Internet, more and more business are done through the Internet. The most important factor that decides a person’s success is the credit. There is a famous example explains how credit influences one’s life. A man took a train in Europe, as there was no one to supervise him, so he thought he could not buy the ticket and ran to the train directly. Later, when the man wanted to interview a job, the employers refused him because they told the man that his credit did not reach their standard. The man realized that he had lost his credit for not buying the ticket for one time, which taught him a lesson to keep his credit. The credit helps us to make friends and cooperate with others well. Don’t lose your credit, or you will lose many chances. 如今，随着互联网的发展，越来越多的业务可以通过互联网来完成。决定一个人是否能成功的最重要因素是信用。有一个很出名的例子解释了信用是如何影响人的一生。一名男子在欧洲坐火车，因为没有人监督，所以他觉得可以不买票，直接朝火车跑去。之后，当这个男子在面试一份工作时，雇主拒绝了他，并告诉这名男子原因是他的信用没有达到他们的标准。男子意识到由于他之前那次没买票他已经失去了信用，这给了他一个教训，要守信用。信用帮助我们交朋友、与其他人顺利合作。不要失去你的信用，否则你会失去很多机会。 4.老一辈有义务去照顾小孩子吗 Is It the Old Generation’s Duty to Look After KidsMany years ago, in order to control the fast growing population, the government carried out the policy of Family Plan, which indeed helped to control the population and make Chinese economy develop fast. Now, the second child policy has been advocated. It is the good news for those families who want to raise one more child. But the problem comes. Many young people need to go to work and they don’t have much time to take care of the new born babies, so they ask their parents to look after their babies. As a result, it seems to be the old generation’s duty to look after the little kids. According to the report, a retired woman became depressed after taking care of her daughter’s second child. Actually, the young people should not rely on their parents too much. Everyone has their personal space. 许多年前，为了控制快速增长的人口，政府实施了计划生育的政策，这的确有助于控制人口，使中国经济快速发展。现在，随着二胎政策的提倡，对于那些想要再抚养一个孩子的家庭来说是好消息。但问题来了，很多年轻人要去工作，他们就没有多少时间去照顾新出生的婴儿，所以他们叫父母帮忙照看孩子。因此，似乎变成是老一代人的责任去照顾小孩子。据报道，一位退休的大妈在照顾她女儿的第二个孩子后患上了抑郁症。实际上，年轻人不应该过于依赖他们的父母，每个人都有自己的私人空间。 5.中国特色无处不在 Chinese Features Are EverywhereChina has the largest population around the world. According to the report, there is one Chinese people among five people, what’s more, as the development of Chinese economy, the world is seeking cooperation with Chinese businessmen, there is no doubt that Chinese economy market is booming. As a result, many foreign countries want to win Chinese tourists, so they put forward many products that are attached with Chinese features. Such as Chinatown, which is a place for Chinese people to work and live. Almost every corner has such a place in the world. Many shops have followed the trend to pay online, just to cater to Chinese tourists, because they get used to use Alipay. People play the joke that even they are in foreign countries, they just feel like home, and many foreigners can speak Chinese. The rise of Chinese economy power is still increasing. 中国有着全世界最多的人口，据报道，每5个人里面就有一个中国人，更重要的是，随着中国经济的发展，全世界都在寻求与中国商人合作的机会，毫无疑问，中国经济市场正在蓬勃发展。因此，许多外国想赢得中国游客，他们推出了许多带有中国特色的产品。如唐人街，这是中国人工作和生活的地方，几乎世界上每个角落都有这样一个地方。许多商店跟随潮流使用在线支付，只是为了迎合中国游客，因为他们习惯使用支付宝。人们开玩笑，即使他们在国外，也觉得像在家里一样，很多外国人都会说中文。中国经济力量的崛起仍在进行中。 6.地球外是否存在生物 Does Living Creatures Exist Outer the EarthPeople are wondering about if there are living creatures in other planets. Scientists have been searching for the answer all the time. Though the official never publishes any information about the existing of another life, most people believe that life exists in outer space. In the science fiction films, the directors try to search the space. They pictured the large galaxy and presented the audience how the aliens looked like. What’s more, some documentaries also recorded the mysterious signs that seemed to be left by the unknown creatures. As a result, the public believes that aliens have come to our planet, or they just pretend to be someone else, studying about human beings. With the development of technology, someday the scientists can go much further and solve the riddles, at that time, we can know more about life. 人们一直想知道在其他行星是否有生物存在。科学家们一直在寻找答案。尽管官方没有发布任何关于其他生命存在的信息，但是大多数人都相信在外太空是有生命存在的。在科幻电影中，导演们试图探索外太空，他们给观众刻画了大型星系和外星人的样子。而且，有些纪录片还记录了神秘的迹象，似乎是由未知生物留下的。因此，公众相信外星人来过地球，或者他们只是假扮成人类，在研究人类。随着科技的发展，总有一天科学家们能走得更远，解开谜底，那时，我们可以对生命有更多的了解。]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站的搭建过程]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle6%2F</url>
    <content type="text"><![CDATA[Hexo —— 快速、简洁且高效的博客框架12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 1.超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 2.支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 3.一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 4.丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Node.js —— 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 不是一个 JavaScript 框架，不同于CakePHP、Django、Rails。Node.js 更不是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 git —— 分布式版本控制系统Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. NexT —— Elegant Theme for Hexo (精于心，简于形)1.主题配置NexT 坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。 2.第三方服务集成使用 第三方服务 来扩展站点的功能， NexT 支持多种常见第三方服务。 评论系统来必力(https://www.livere.com)123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC80MTgyMS8xODM2Nw== 数据统计与分析百度统计(https://tongji.baidu.com/web/welcome/login)12# Baidu Analytics IDbaidu_analytics: 05b9e90829bd8b83641409c77e41d36a 阅读次数统计（LeanCloud)123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 0Bkl73pRei0NBwLm1JnzAagz-gzGzoHsz app_key: QjEOooUCUuj2kvBUlrlRP1gt 内容分享服务JiaThis(http://www.jiathis.com)123456# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https. jiathis: true ##uid: Get this uid from http://www.jiathis.com/ 搜索服务Local Search(https://github.com/flashlab/hexo-generator-search)12345678910111213141516$ npm install hexo-generator-searchdb --save# 搜索search: path: search.xml field: post format: html limit: 10000# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 3.内置标签除了 Markdown 支持的语法之外，NexT 借助 Hexo 提供的标签特性， 为您提供在书写文档时快速插入带特殊样式的内容。 4.常见问题NexT 使用中常见的问题。当您在使用中有疑问的时候，不妨先来这里看看。 或者在这里分享您在使用过程中碰到的问题。 GitHub —— 是一个面向开源及私有软件项目的托管平台gitHub因为只支持git作为唯一的版本库格式进行托管，故名gitHub。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 在GitHub进行分支就像在Myspace（或Facebook…）进行交友一样，在社会关系图的节点中不断的连线。 GitHub项目本身自然而然的也在GitHub上进行托管，只不过在一个私有的，公共视图不可见的库中。开源项目可以免费托管，但私有库则并不如此。Chris Wanstrath，GitHub的开发者之一，肯定了通过付费的私有库来在财务上支持免费库的托管这一计划。 是的，我们正是这么计划的。通过与客户的接洽，开发FamSpam，甚至是开发GitHub本身，GitHub的私有库已经被证明了物有所值。任何希望节省时间并希望和团队其它成员一样远离页面频繁转换之苦的人士都会从GitHub中获得他们真正想要的价值。 在GitHub，用户可以十分轻易地找到海量的开源代码。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2018%2F12%2F25%2Ftitle5%2F</url>
    <content type="text"><![CDATA[hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器1234hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 123hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的12hexo generate --deployhexo deploy --generate 12hexo deploy -ghexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模板12345hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHub 123hexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上123hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署1ERROR Deployer not found: git 解决方法 1npm install hexo-deployer-git --save 3.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuild12xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance 1npm install bcrypt 5. RSS不显示安装RSS插件1npm install hexo-generator-feed --save 开启RSS功能编辑hexo/_config.yml，添加如下代码： 1rss: /atom.xml #rss地址 默认即可 开启评论我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 1.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 2.复制到 themes\landscape\layout_partial\article.ejs 把 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 改为 1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（4）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle4%2F</url>
    <content type="text"><![CDATA[javascript面向对象中继承实现？面向对象的基本特征有：封闭、继承、多态。 在JavaScript中实现继承的方法： 原型链（prototype chaining） call()/apply() 混合方式(prototype和call()/apply()结合) 对象冒充 继承的方法如下： 1、prototype原型链方式： 1234567891011121314151617 function teacher(name)&#123; this.name = name;&#125;teacher.prototype.sayName = function()&#123; console.log("name is "+this.name);&#125;var teacher1 = new teacher("xiaoming");teacher1.sayName(); function student(name)&#123; this.name = name;&#125;student.prototype = new teacher()var student1 = new student("xiaolan");student1.sayName();// name is xiaoming// name is xiaolan 2、call()/apply()方法 1234567891011121314151617181920function teacher(name,age)&#123;this.name = name;this.age = age;this.sayhi = function()&#123;alert('name:'+name+", age:"+age);&#125;&#125;function student()&#123;var args = arguments;teacher.call(this,args[0],args[1]);// teacher.apply(this,arguments);&#125;var teacher1 = new teacher('xiaoming',23);teacher1.sayhi();var student1 = new student('xiaolan',12);student1.sayhi();// alert: name:xiaoming, age:23// alert: name:xiaolan, age:12 3、混合方法【prototype,call/apply】 12345678910111213141516171819202122function teacher(name,age)&#123;this.name = name;this.age = age;&#125;teacher.prototype.sayName = function()&#123;console.log('name:'+this.name);&#125;teacher.prototype.sayAge = function()&#123;console.log('age:'+this.age);&#125;function student()&#123;var args = arguments;teacher.call(this,args[0],args[1]);&#125;student.prototype = new teacher();var student1 = new student('xiaolin',23);student1.sayName();student1.sayAge();// name:xiaolin// age:23 4、对象冒充 123456789101112131415161718192021function Person(name,age)&#123;this.name = name;this.age = age;this.show = function()&#123;console.log(this.name+", "+this.age);&#125;&#125;function Student(name,age)&#123;this.student = Person; //将Person类的构造函数赋值给this.studentthis.student(name,age); //js中实际上是通过对象冒充来实现继承的delete this.student; //移除对Person的引用&#125;var s = new Student("小明",17);s.show();var p = new Person("小花",18);p.show();// 小明, 17// 小花, 18 javascript相关程序计算题1、判断一个字符串中出现次数最多的字符，统计这个次数123456789101112131415161718var str = 'asdfssaaasasasasaa';var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = '';for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125;&#125; console.log('出现次数最多的是:'+iIndex+'出现'+iMax+'次'); 结果如下：出现次数最多的是:a出现9次 JavaScript 数组(Array)对象1、Array相关的属性和方法这里只是做了相关的列举，具体的使用方法，请参考网址。 Array 对象属性constructor 返回对创建此对象的数组函数的引用。 length 设置或返回数组中元素的数目。 prototype 使您有能力向对象添加属性和方法。 Array 对象方法concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素。 shift() 删除并返回数组的第一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 2、编写一个方法 去掉一个数组的重复元素方法一： 12345678910var arr = [0,2,3,4,4,0,2];var obj = &#123;&#125;;var tmp = [];for(var i = 0 ;i&lt; arr.length;i++)&#123; if( !obj[arr[i]] )&#123; obj[arr[i]] = 1; tmp.push(arr[i]); &#125;&#125;console.log(tmp); 结果如下： [0, 2, 3, 4] 方法二： 12345678var arr = [2,3,4,4,5,2,3,6], arr2 = [];for(var i = 0;i&lt; arr.length;i++)&#123; if(arr2.indexOf(arr[i]) &lt; 0)&#123; arr2.push(arr[i]); &#125;&#125;console.log(arr2); 结果为：[2, 3, 4, 5, 6] 方法三： 12345var arr = [2,3,4,4,5,2,3,6];var arr2 = arr.filter(function(element,index,self)&#123;return self.indexOf(element) === index;&#125;);console.log(arr2); 结果为：[2, 3, 4, 5, 6]]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（3）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle3%2F</url>
    <content type="text"><![CDATA[如何理解闭包？1、定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 2、表现形式：使函数外部能够调用函数内部定义的变量。 3、实例如下： (1)、根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count 。 1234567891011var count=10; //全局作用域 标记为flag1function add()&#123; var count=0; //函数全局作用域 标记为flag2 return function()&#123; count+=1; //函数的内部作用域 alert(count); &#125;&#125;var s = add()s();//输出1s();//输出2 4、变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域分类：全局变量和局部变量。 特点： 1、函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。 2、函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 5、使用闭包的注意点 1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况： 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90. 2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。 实现方法：通过nginx代理； 注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。 (2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。 使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; "Content-Type": "text/html; charset=UTF-8", "Access-Control-Allow-Origin":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。 特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。 实例如下： 1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = "text/javascript"; _script.src = "http://localhost:8888/jsonp?callback=testjsonp"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。 谈谈垃圾回收机制方式及内存管理回收机制方式1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。 2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 3、实例如下： 123456789function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 4、垃圾回收策略：标记清除(较为常用)和引用计数。 标记清除： 定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数： 定义和用法：引用计数是跟踪记录每个值被引用的次数。 基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。 内存管理1、什么时候触发垃圾回收？ 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。 IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。 IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。 2、合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。 3、GC缺陷：(1)、停止响应其他操作； 4、GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC 开发过程中遇到的内存泄露情况，如何解决的？1、定义和用法： 内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。 2、内存泄露的几种情况: (1)、当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 实例如下: 123456789&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; document.getElementById("myDiv").innerHTML = "Processing..."; &#125;&lt;/script&gt; 解决方法如下： 12345678910&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; btn.onclick = null; document.getElementById("myDiv").innerHTML = "Processing..."; &#125;&lt;/script&gt; (2)、由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。实例如下： 123456function bindEvent()&#123; var obj=document.createElement("XXX"); obj.onclick=function()&#123; //Even if it's a empty function &#125;&#125; 解决方法如下： 1234567function bindEvent()&#123; var obj=document.createElement("XXX"); obj.onclick=function()&#123; //Even if it's a empty function &#125; obj=null;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（2）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle2%2F</url>
    <content type="text"><![CDATA[js 字符串操作函数我这里只是列举了常用的字符串函数，具体使用方法，请参考网址。 concat() – 将两个或多个字符的文本组合起来，返回一个新的字符串。 indexOf() – 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 。 charAt() – 返回指定位置的字符。 lastIndexOf() – 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 。 match() – 检查一个字符串是否匹配一个正则表达式。 substr() 函数 – 返回从string的startPos位置，长度为length的字符串 substring() – 返回字符串的一个子串。传入参数是起始位置和结束位置。 slice() – 提取字符串的一部分，并返回一个新字符串。 replace() – 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 search() – 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 split() – 通过将字符串划分成子串，将一个字符串做成一个字符串数组。 length – 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 toLowerCase() – 将整个字符串转成小写字母。 toUpperCase() – 将整个字符串转成大写字母。 怎样添加、移除、移动、复制、创建和查找节点？1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 写出3个使用this的典型应用（1）、在html元素事件属性中使用，如：1&lt;input type=”button” onclick=”showInfo(this);” value=”点击一下”/&gt; （2）、构造函数1234function Animal(name, color) &#123; this.name = name; this.color = color;&#125; （3）、input点击，获取值1234567&lt;input type="button" id="text" value="点击一下" /&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("text"); btn.onclick = function() &#123; alert(this.value); //此处的this是按钮元素 &#125;&lt;/script&gt; （4）、apply()/call()求数组最值12345var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(this, numbers); console.log(maxInNumbers); // 458var maxInNumbers = Math.max.call(this,5, 458 , 120 , -215); console.log(maxInNumbers); // 458 比较typeof与instanceof？相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。 (2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。 (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 实例演示： 12345a instanceof b?alert("true"):alert("false"); //a是b的实例？真:假var a = new Array(); alert(a instanceof Array); // truealert(a instanceof Object) // true 如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。 123function test()&#123;&#125;;var a = new test();alert(a instanceof test) // true 细节： (1)、如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。 1if (window instanceof Object)&#123; alert('Y')&#125; else &#123; alert('N');&#125; // 'N']]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（1）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle1%2F</url>
    <content type="text"><![CDATA[本篇收录了一些面试中经常会遇到的经典面试题以及自己面试过程中遇到的一些问题，并且都给出了我在网上收集的答案。马上就要过春节了，开年就是崭新的一年，相信很多的前端开发者会有一些跳槽的悸动，通过对本篇知识的整理以及经验的总结，希望能帮到更多的前端面试者。（如有错误或更好的答案，欢迎指正，水平有限，望各位不吝指教。） JavaScript:JavaScript中如何检测一个变量是一个String类型？请写出函数实现123typeof(obj) === "string"typeof obj === "string"obj.constructor === String 请用js去除字符串空格？方法一：使用replace正则匹配的方法去除所有空格: str = str.replace(/\s*/g,””); 去除两头空格: str = str.replace(/^\s|\s$/g,””); 去除左空格： str = str.replace( /^\s*/, “”); 去除右空格： str = str.replace(/(\s*$)/g, “”); str为要去除空格的字符串，实例如下： 123var str = " 23 23 ";var str2 = str.replace(/\s*/g,"");console.log(str2); // 2323 方法二：使用str.trim()方法str.trim()局限性：无法去除中间的空格，实例如下： 123var str = " xiao ming ";var str2 = str.trim();console.log(str2); //xiao ming 同理，str.trimLeft()，str.trimRight()分别用于去除字符串左右空格。 方法三：使用jquery,$.trim(str)方法$.trim(str)局限性：无法去除中间的空格，实例如下： 123var str = " xiao ming ";var str2 = $.trim(str)console.log(str2); // xiao ming 你如何获取浏览器URL中查询字符串中的参数？实例如下： 12345678910111213141516function showWindowHref()&#123; var sHref = window.location.href; var args = sHref.split('?'); if(args[0] == sHref)&#123; return ""; &#125; var arr = args[1].split('&amp;'); var obj = &#123;&#125;; for(var i = 0;i&lt; arr.length;i++)&#123; var arg = arr[i].split('='); obj[arg[0]] = arg[1]; &#125; return obj;&#125;var href = showWindowHref(); // objconsole.log(href['name']); // xiaoming]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
