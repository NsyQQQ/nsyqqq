<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git命令笔记]]></title>
    <url>%2F2018%2F12%2F29%2Ftitle11%2F</url>
    <content type="text"><![CDATA[git基本命令1.git常用命令一般配置123git --version //查看git的版本信息git config --global user.name //获取当前登录的用户git config --global user.email //获取当前登录用户的邮箱 登录git1234/* 如果刚没有获取到用户配置，则只能拉取代码，不能修改 要是使用git，你要告诉git是谁在使用*/git config --global user.name &apos;userName&apos; //设置git账户，userName为你的git账号git config --global user.email &apos;email&apos; //email为你的邮箱地址 创建一个文件夹12mkdir nodejs //创建文件夹nodejscd nodejs //切换到nodejs目录下 初始化git仓库1git init //在nodejs文件夹下初始化一个仓库，此时文件里会到一个.git的隐藏文件夹 创建忽略文件12345touch .gitignore //不需要服务器端提交的内容可以写到忽略文件里 /* .git .idea */ 查看目录1ls -al 创建文件并写入内容如果文件不存在则会创建文件 12echo &quot;hello git&quot; &gt; index.html //将&apos;hello git&apos; 写入到index.html中 单个&gt;箭头表示写入， &gt;&gt;表示追加 查看文件内容1cat index.html 增加到暂存区中12git add index.htmlgit add -A //全部添加到缓存区 增加到版本库中1git commit -m &apos;备注信息&apos; 查看版本1git log --oneline 比较差异比较的是暂存区和工作区的差异 1git diff 比较的是暂存区和历史区的差异 1git diff --cached 比较的是历史区和工作区的差异（修改） 1git diff master 撤回内容(如果修改了工作区的文件后发现改错了，可以用暂存区或者版本库里的文件替换掉工作区的文件) 用暂存区中的内容或者版本库中的内容覆盖掉工作区 1git checkout index.html 取消增加到暂存区的内容（添加时） 123git reset HEAD index.html//显示目录的状体 有没有添加或者修改文件git status 删除本地文件1rm fileName 删除暂存区保证当前工作区中没有index.html 1git rm index.html --cached 使用–cached 表示只删除缓存区中的内容 回滚版本回滚最近的一个版本 git log 1git reset --hard HEAD/commit_id 回滚到未来1git reflog 2.分支管理创建分支1git branch dev 切换分支1git checkout dev 创建分支并切换分支1git checkout -b dev 删除分支1git branch -d dev 在分支上提交新的版本1git commit -a -m &apos;dev1&apos; 合并分支1git merge dev 分支的合并后显示log1git log --oneline --graph --decorate 在分支开发的过程中遇到其他问题需要切换其他分支保留写好的内容在切换到主干 保留内容 1git stash 在次切换分之后需要应用一下保留的内容1git stash apply 丢掉保存的内容1git stash drop 使用并丢掉1git stash pop 最佳分支有的时候开发需要合并指定的内容，而不是合并所有的提交，所以我们需要挑选最好的，自己生产版本。 合并分支把树杈掰到主干上1git rebase 3.添加远程的仓库push -u-u参数 upstream 1git push origin master -u //获取最新代码 连接远程仓库1git remote add origin 仓库的地址 查看远程仓库1git remote -v 删除远程仓库1git remote rm origin 4.git常用命令安装及配置：Ubuntu下安装：sudo apt-get install git配置用户名：git config –global user.name “你的名字”配置e-mail：git config –global user.email “你的邮箱@xx.com” 与添加有关的：将当前目录变为仓库：git init将文件添加到暂存区：git add 文件名 [可选：另一个文件名]将暂存区提交到仓库：git commit –m “描述” 与查询有关的：查询仓库状态：git status比较文件差异（请在git add之前使用）：git diff 文件名查看仓库历史记录(详细)：git log查看仓库历史记录(单行)：git log –pretty=online 或 git log –online查看所有版本的commit ID：git reflog 与撤销有关的：撤销工作区的修改：git checkout – 文件名撤销暂存区的修改：git reset HEAD 文件名回退到历史版本：git reset –hard 该版本ID回退到上个版本：git reset –hard HEAD^上上版本是HEAD^^，也可用HEAD~2表示，以此类推 与标签有关的：为当前版本打标签：git tag 标签名为历史版本打标签：git tag 标签名 该版本ID指定标签说明：git tag –a 标签名 –m “标签说明” [可选：版本ID]查看所有标签：git tag查看某一标签：git show 标签名删除某一标签：git tag –d 标签名 与GitHub有关的：先有本地库，后有远程库，将本地库push到远程库关联本地仓库和GitHub库：git remote add origin 网站上的仓库地址第一次将本地仓库推送到GitHub上：git push –u origin master 先有远程库，后有本地库，从远程库clone到本地库从远程库克隆到本地：git clone 网站上的仓库地址 网站地址可以选择HTTPS协议（https://github.com...）、SSH协议（git@github.com...）。如果选择SSH协议，必须将Ubuntu的公钥添加到GitHub上。见下一步 SSH Key生成SSH Key：ssh-keygen –t rsa –C “你的邮箱@xx.com”生成Key时弹出选项，回车选择默认即可。Key保存位置：/root/.ssh登陆GitHub，创建new SSH key，其内容为/root/.ssh/id_rsa.pub中文本 已经有了本地库和远程库，二者实现同步本地库的改动提交到远程库：git push origin master更新本地库至远程库的最新改动：git pull]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>git和github</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git和github]]></title>
    <url>%2F2018%2F12%2F29%2Ftitle10%2F</url>
    <content type="text"><![CDATA[一、什么是git和github？1.GIT（分布式版本控制系统）对于分布式版本控制系统，每个用户中都有自己在本地的仓库用来管理版本控制，每个客户端也同时是一个服务器。同时也可以用一个专门的服务器的仓库用来管理。 分布式版本控制系统的不同用户之间，只要是在同一个局域网都是想通的，入上图所示。所以某一个用户协同工作的服务器发生故障，并不会影响到整个团队。 与集中式版本控制系统相比： 1) 分布式版本控制系统更安全，因为每个客户端都是一个服务器，拥有一个完整地版本库，包括所有的历史记录等； 2) 工作效率会更高，因为对于小的修改，用户可以先把新版本的文件提交到本地的仓库，本地提交的速度远远快于“远程”提交； 3) 如果是在同一个局域网，不同用户之间可以相互访问； 4) 对于非局域网协同工作的，可以创建一个连接互联网的的服务器仓库。 Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持，使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。 目前GIT已经可以在windows下使用，主要方法有二：msysgit和Cygwin。Cygwin和Linux使用方法类似，Windows版本的GIT提供了友好的GUI(图形界面)，安装后很快可以上手。 2.githubgitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 gitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 GitHub 使用 git 分布式版本控制系统，而 git 最初是 LinusTorvalds 为帮助Linux开发而创造的，它针对的是 Linux 平台，因此 git 和 Windows 从来不是最好的朋友，因为它一点也不像 Windows。GitHub 发布了GitHub for Windows，为 Windows 平台开发者提供了一个易于使用的 Git 图形客户端。 GitHub for Windows 是一个 Metro 风格应用程序，集成了自包含版本的 Git，bash 命令行 shell，PowerShell 的 posh-git 扩展。GitHub 为 Windows 用户提供了一个基本的图形前端去处理大部分常用版本控制任务，可以创建版本库，向本地版本库递交补丁，在本地和远程版本库之间同步。 二、git与github的区别一开始接触git或是github的程序员可能搞不太清楚这些名词到底指代的是什么，所以在这里稍微说明一下。git和github是两个完全不同的概念。 git是一个版本管理工具，是可以在你电脑不联网的情况下，只在本地使用的一个版本管理工具，其作用就是可以让你更好的管理你的程序，比如你原来提交过的内容，以后虽然修改了，但是通过git这个工具，可以把你原来提交的内容重现出来，这样对于你后来才意识到的一些错误的更改，可以进行还原，具体有关git的简介，我觉得有一个教程写的非常的详细，比较适合新手的学习，这是链接：Git教程 关于github，这是一个网站，就是每个程序员自己写的程序，可以在github上建立一个网上的仓库，你每次提交的时候可以把代码提交到网上，这样你的每次提交，别人也都可以看到你的代码，同时别人也可以帮你修改你的代码，这种开源的方式非常方便程序员之间的交流和学习。 github是一个非常适合程序员交流的网站，很多国际上的技术大牛都在github上有自己的开源代码，其他人只要申请个账号就可以随意的看到这些大牛写的程序。同时国内的很多互联网公司如百度，阿里等，也在github上公布有开源的代码，感兴趣的程序员也可以自己查找着看一些。 总结来说，git可以认为是一个软件，能够帮你更好的写程序，github则是一个网站，这个网站可以帮助程序员之间互相交流和学习。]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>git和github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS预处理器（Sass、Less和Stylus）]]></title>
    <url>%2F2018%2F12%2F29%2Ftitle9%2F</url>
    <content type="text"><![CDATA[一、什么是Sass、Less和Stylus？Sass、Less和Stylus都属于CSS预处理器，那什么是 CSS 预处理器呢？ CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就 只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。 CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基 本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 CSS预处理器技术已经非常的成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、 Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、 CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。 到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将分别从他们产生的背 景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。 二、为什么要使用CSS预处理器？作为前端开发人员，大家都知道，Js中可以自定义变量，而CSS仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。 CSS有具体以下几个缺点： 1.语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；2.没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。 这就导致了我们在工作中无端增加了许多工作量。而使用CSS预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。 但是，CSS预处理器也不是万金油，CSS的好处在于简便、随时随地被使用和调试。预编译CSS步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。 所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS预处理器有没有解决更大的麻烦。 三、Sass、LESS和Stylus背景介绍为了能更好的了解这三款流行的CSS预处理器，我们先从其背景入手，简单的了解一下各自的背景信息。 1.Sass背景介绍Sass是对CSS（层叠样式表）的语法的一种扩充，诞生于2007年，最早也是最成熟的一款CSS预处理器语言，它可以使用变量、常量、嵌套、混 入、函数等功能，可以更有效有弹性的写出CSS。Sass最后还是会编译出合法的CSS让浏览器使用，也就是说它本身的语法并不太容易让浏览器识别，因为 它不是标准的CSS格式，在它的语法内部可以使用动态变量等，所以它更像一种极简单的动态语言。 其实现在的Sass已经有了两套语法规则：一个依旧是用缩进作为分隔符来区分代码块的；另一套规则和CSS一样采用了大括号（｛｝）作为分隔符。后一种语法规则又名SCSS，在Sass3之后的版本都支持这种语法规则。 注：Sass官网地址：http://sass-lang.com 2.LESS的背景介绍2009年开源的一个项目，受Sass的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手。LESS提供了多种方式能平滑的将写 好的代码转化成标准的CSS代码，在很多流行的框架和工具中已经能经常看到LESS的身影了（例如Twitter的Bootstrap框架就使用了 LESS）。 根据维基百科上的介绍，其实LESS是Alexis Sellier受Sass的影响创建的一个开源项目。当时SASS采用了缩进作为分隔符来区分代码块，而不是CSS中广为使用的大括号（｛｝）。为了让 CSS现有的用户使用起来更佳方便，Alexis开发了LESS并提供了类似CSS的书写功能。 注：LESS的官网：http://lesscss.org 3.Stylus背景介绍Stylus，2010年产生，来自于Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如Sass和LESS。 Stylus被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成CSS，以供浏览器使用。Stylus同时支持缩进和CSS常规样式书写规则。 注：Stylus官网：http://learnboost.github.com/stylus 四、Sass和Less的比较不同之处1.Less环境较Sass简单Cass的安装需要安装Ruby环境，Less基于JavaScript，是需要引入Less.js来处理代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放在项目中，有less.app、SimpleLess、CodeKit.app这样的工具，也有在线编辑地址。 2、Less使用较Sass简单LESS 并没有裁剪 CSS 原有的特性，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。只要你了解 CSS 基础就可以很容易上手。 3、从功能出发，Sass较Less略强大一些(1) sass有变量和作用域 $variable，like php； #｛$variable｝like ruby； 变量有全局和局部之分，并且有优先级。 (2) sass有函数的概念 @function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。 @mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。 ruby提供了非常丰富的内置原生api。 (3) 进程控制 条件：@if @else； 循环遍历：@for @each @while 继承：@extend 引用：@import (4) 数据结构 $list类型=数组； $map类型=object；其余的也有string、number、function等类型 4、Less与Sass处理机制不一样前者是通过客户端处理的，后者是通过服务端处理，相比较之下前者解析会比后者慢一点。 5、关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。相同之处Less和Sass在语法上有些共性，比如下面这些： 1、混入(Mixins)——class中的class；2、参数混入——可以传递参数的class，就像函数一样；3、嵌套规则——Class中嵌套class，从而减少重复的代码；4、运算——CSS中用上数学；5、颜色功能——可以编辑颜色；6、名字空间(namespace)——分组样式，从而可以被调用；7、作用域——局部修改样式；8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。 五、为什么选择使用Sass而不是Less？1、Sass在市面上有一些成熟的框架，比如说Compass，而且有很多框架也在使用Sass，比如说Foundation。2、就国外讨论的热度来说，Sass绝对优于LESS。3、就学习教程来说，Sass的教程要优于LESS。在国内LESS集中的教程是LESS中文官网，而Sass的中文教程，慢慢在国内也较为普遍。4、Sass也是成熟的CSS预处理器之一，而且有一个稳定，强大的团队在维护。5、同时还有Scss对sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。6、bootstrap（Web框架）最新推出的版本4，使用的就是Sass。]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Sass</tag>
        <tag>Less</tag>
        <tag>Stylus</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3属性笔记]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle8%2F</url>
    <content type="text"><![CDATA[新的边框属性 属性 描述 CSS border-image 设置所有 border-image-* 属性的简写属性。 3 border-radius 设置所有四个 border-*-radius 属性的简写属性。 3 box-shadow 向方框添加一个或多个阴影。 3 新的背景属性 属性 描述 CSS background-clip 规定背景的绘制区域。 3 background-origin 规定背景图片的定位区域。 3 background-size 规定背景图片的尺寸。 3 新的文本属性 属性 描述 CSS hanging-punctuation 规定标点字符是否位于线框之外。 3 punctuation-trim 规定是否对标点字符进行修剪。 3 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 3 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 3 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 3 text-outline 规定文本的轮廓。 3 text-overflow 规定当文本溢出包含元素时发生的事情。 3 text-shadow 向文本添加阴影。 3 text-wrap 规定文本的换行规则。 3 word-break 规定非中日韩文本的换行规则。 3 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 3 CSS3 字体描述符下面的表格列出了能够在 @font-face 规则中定义的所有字体描述符： 描述符 值 描述 font-family name 必需。规定字体的名称。 src URL 必需。定义字体文件的 URL。 font-stretch normal condensed ultra-condensed extra-condensed semi-condensed expanded semi-expanded extra-expanded ultra-expanded 可选。定义如何拉伸字体。默认是 “normal”。 font-style ormal italic oblique 可选。定义字体的样式。默认是 “normal”。 font-weight normal bold 可选。定义字体的粗细。默认是 “normal”。 unicode-range unicode-range 可选。定义字体支持的 UNICODE 字符范围。默认是 “U+0-10FFFF”。 新的转换属性 属性 描述 CSS transform 向元素应用 2D 或 3D 转换。 3 transform-origin 允许你改变被转换元素的位置。 3 transform-style 规定被嵌套元素如何在 3D 空间中显示。 3 perspective 规定 3D 元素的透视效果。 3 perspective-origin 规定 3D 元素的底部位置。 3 backface-visibility 定义元素在不面对屏幕时是否可见。 3 过渡属性下面的表格列出了所有的转换属性： 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 CSS3 动画属性下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 animation-fill-mode 规定对象动画时间之外的状态。 3 3 新的多列属性下面的表格列出了所有的转换属性： 属性 描述 CSS column-count 规定元素应该被分隔的列数。 3 column-fill 规定如何填充列。 3 column-gap 规定列之间的间隔。 3 column-rule 设置所有 column-rule-* 属性的简写属性。 3 column-rule-color 规定列之间规则的颜色。 3 column-rule-style 规定列之间规则的样式。 3 column-rule-width 规定列之间规则的宽度。 3 column-span 规定元素应该横跨的列数。 3 column-width 规定列的宽度。 3 columns 规定设置 column-width 和 column-count 的简写属性。 3 新的用户界面属性下面的表格列出了所有的转换属性： 属性 描述 CSS appearance 允许您将元素设置为标准用户界面元素的外观 3 box-sizing 允许您以确切的方式定义适应某个区域的具体内容。 3 icon 为创作者提供使用图标化等价物来设置元素样式的能力。 3 nav-down 规定在使用 arrow-down 导航键时向何处导航。 3 nav-index 设置元素的 tab 键控制次序。 3 nav-left 规定在使用 arrow-left 导航键时向何处导航。 3 nav-right 规定在使用 arrow-right 导航键时向何处导航。 3 nav-up 规定在使用 arrow-up 导航键时向何处导航。 3 outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 3 resize 规定是否可由用户对元素的尺寸进行调整。 3]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语作文（1）]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle7%2F</url>
    <content type="text"><![CDATA[1.不要嘲笑别人的梦想 Don’t Laugh at Someone Else’ DreamsRecently, I saw an impressive story. A girl from America was laughed by her classmates, because she had a model dream. They told her that she was fat and looked homely, so it was impossible for her to be a model. The girl gave up going to school but she chose to study at home. She continued her passion for fashion, now she became a fashion blogger, and her followers were more than one million. What an inspiring story. Look at those people who laughed at her dream. They should be shameful on themselves. We should not laugh at someone else’s dream, no matter what kind of dreams they have. It is their motivation to move on and make progress. Most of them become somebody in the future if they insist on. The world becomes beautiful if we give support to each other. 最近，我看到一个令人印象深刻的故事。一个来自美国的女孩被同学嘲笑，因为她的梦想是当模特。他们告诉她，她很胖，而且看起来很平凡，所以这对她来说是不可能成为一名模特的。这个女孩放弃了上学，但她选择在家学习，也没有放弃对时尚的热情，现在她成为时尚博主，她的粉丝超过了一百万人。多么鼓舞人心的故事啊，看看那些嘲笑她梦想的人，他们应该感到羞耻。我们不应该嘲笑别人的梦想，无论他们的梦想是什么。这是他们前进和取得进步的动力。如果他们坚持的话，他们中的大多数人将来会成为有出息的人。如果我们相互支持世界会变得美好。 2.长时间玩游戏的后果 The Result of Playing Games For a Long TimeNowadays, young people like to play online games so much. Once they have time, they will take out their cellphones and then get addicted to it. So we can see people low down their heads everywhere, such as the bus station, the dinner table even they are walking down the street. How crazy it is. Though most people have been told the danger of playing games for hours, they still ignored it. Recently, a woman was reported to turn blind after playing online games for a long time. When she was sent to hospital, the doctor told her family they could do nothing to fix her eyes. What a great tragedy. At this young age, everybody can enjoy a happy life. We should take the regular exercise and keep the healthy lifestyle, stopping to play cellphone for hours. 如今，年轻人喜欢玩网络游戏，一旦他们有时间，就会拿出自己的手机，然后沉迷于玩游戏。所以我们可以随处看到人们低下头来，比如在公交车站，餐桌上甚至走在街上。这有多疯狂啊。大多数人虽然都被告知过长时间玩游戏的危害，但是他们仍然无视。最近，据报道，一名女子在玩了很长一段时间网络游戏后失明了，她被送到医院时，医生告诉她的家人，已经无法修复她的眼睛了。真是个悲剧。在这么小的年龄，每个人都应该享受快乐的生活，我们应该经常锻炼并保持健康的生活方式，停止长时间玩手机了。 3.信用的重要性 The Importance of CreditNowadays, with the development of Internet, more and more business are done through the Internet. The most important factor that decides a person’s success is the credit. There is a famous example explains how credit influences one’s life. A man took a train in Europe, as there was no one to supervise him, so he thought he could not buy the ticket and ran to the train directly. Later, when the man wanted to interview a job, the employers refused him because they told the man that his credit did not reach their standard. The man realized that he had lost his credit for not buying the ticket for one time, which taught him a lesson to keep his credit. The credit helps us to make friends and cooperate with others well. Don’t lose your credit, or you will lose many chances. 如今，随着互联网的发展，越来越多的业务可以通过互联网来完成。决定一个人是否能成功的最重要因素是信用。有一个很出名的例子解释了信用是如何影响人的一生。一名男子在欧洲坐火车，因为没有人监督，所以他觉得可以不买票，直接朝火车跑去。之后，当这个男子在面试一份工作时，雇主拒绝了他，并告诉这名男子原因是他的信用没有达到他们的标准。男子意识到由于他之前那次没买票他已经失去了信用，这给了他一个教训，要守信用。信用帮助我们交朋友、与其他人顺利合作。不要失去你的信用，否则你会失去很多机会。 4.老一辈有义务去照顾小孩子吗 Is It the Old Generation’s Duty to Look After KidsMany years ago, in order to control the fast growing population, the government carried out the policy of Family Plan, which indeed helped to control the population and make Chinese economy develop fast. Now, the second child policy has been advocated. It is the good news for those families who want to raise one more child. But the problem comes. Many young people need to go to work and they don’t have much time to take care of the new born babies, so they ask their parents to look after their babies. As a result, it seems to be the old generation’s duty to look after the little kids. According to the report, a retired woman became depressed after taking care of her daughter’s second child. Actually, the young people should not rely on their parents too much. Everyone has their personal space. 许多年前，为了控制快速增长的人口，政府实施了计划生育的政策，这的确有助于控制人口，使中国经济快速发展。现在，随着二胎政策的提倡，对于那些想要再抚养一个孩子的家庭来说是好消息。但问题来了，很多年轻人要去工作，他们就没有多少时间去照顾新出生的婴儿，所以他们叫父母帮忙照看孩子。因此，似乎变成是老一代人的责任去照顾小孩子。据报道，一位退休的大妈在照顾她女儿的第二个孩子后患上了抑郁症。实际上，年轻人不应该过于依赖他们的父母，每个人都有自己的私人空间。 5.中国特色无处不在 Chinese Features Are EverywhereChina has the largest population around the world. According to the report, there is one Chinese people among five people, what’s more, as the development of Chinese economy, the world is seeking cooperation with Chinese businessmen, there is no doubt that Chinese economy market is booming. As a result, many foreign countries want to win Chinese tourists, so they put forward many products that are attached with Chinese features. Such as Chinatown, which is a place for Chinese people to work and live. Almost every corner has such a place in the world. Many shops have followed the trend to pay online, just to cater to Chinese tourists, because they get used to use Alipay. People play the joke that even they are in foreign countries, they just feel like home, and many foreigners can speak Chinese. The rise of Chinese economy power is still increasing. 中国有着全世界最多的人口，据报道，每5个人里面就有一个中国人，更重要的是，随着中国经济的发展，全世界都在寻求与中国商人合作的机会，毫无疑问，中国经济市场正在蓬勃发展。因此，许多外国想赢得中国游客，他们推出了许多带有中国特色的产品。如唐人街，这是中国人工作和生活的地方，几乎世界上每个角落都有这样一个地方。许多商店跟随潮流使用在线支付，只是为了迎合中国游客，因为他们习惯使用支付宝。人们开玩笑，即使他们在国外，也觉得像在家里一样，很多外国人都会说中文。中国经济力量的崛起仍在进行中。 6.地球外是否存在生物 Does Living Creatures Exist Outer the EarthPeople are wondering about if there are living creatures in other planets. Scientists have been searching for the answer all the time. Though the official never publishes any information about the existing of another life, most people believe that life exists in outer space. In the science fiction films, the directors try to search the space. They pictured the large galaxy and presented the audience how the aliens looked like. What’s more, some documentaries also recorded the mysterious signs that seemed to be left by the unknown creatures. As a result, the public believes that aliens have come to our planet, or they just pretend to be someone else, studying about human beings. With the development of technology, someday the scientists can go much further and solve the riddles, at that time, we can know more about life. 人们一直想知道在其他行星是否有生物存在。科学家们一直在寻找答案。尽管官方没有发布任何关于其他生命存在的信息，但是大多数人都相信在外太空是有生命存在的。在科幻电影中，导演们试图探索外太空，他们给观众刻画了大型星系和外星人的样子。而且，有些纪录片还记录了神秘的迹象，似乎是由未知生物留下的。因此，公众相信外星人来过地球，或者他们只是假扮成人类，在研究人类。随着科技的发展，总有一天科学家们能走得更远，解开谜底，那时，我们可以对生命有更多的了解。]]></content>
      <categories>
        <category>学习</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站的搭建过程]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle6%2F</url>
    <content type="text"><![CDATA[Hexo —— 快速、简洁且高效的博客框架12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 1.超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 2.支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 3.一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 4.丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Node.js —— 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 不是一个 JavaScript 框架，不同于CakePHP、Django、Rails。Node.js 更不是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 git —— 分布式版本控制系统Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. NexT —— Elegant Theme for Hexo (精于心，简于形)1.主题配置NexT 坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。 2.第三方服务集成使用 第三方服务 来扩展站点的功能， NexT 支持多种常见第三方服务。 评论系统来必力(https://www.livere.com)123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC80MTgyMS8xODM2Nw== 数据统计与分析百度统计(https://tongji.baidu.com/web/welcome/login)12# Baidu Analytics IDbaidu_analytics: 05b9e90829bd8b83641409c77e41d36a 阅读次数统计（LeanCloud)123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 0Bkl73pRei0NBwLm1JnzAagz-gzGzoHsz app_key: QjEOooUCUuj2kvBUlrlRP1gt 内容分享服务JiaThis(http://www.jiathis.com)123456# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https. jiathis: true ##uid: Get this uid from http://www.jiathis.com/ 搜索服务Local Search(https://github.com/flashlab/hexo-generator-search)12345678910111213141516$ npm install hexo-generator-searchdb --save# 搜索search: path: search.xml field: post format: html limit: 10000# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 3.内置标签除了 Markdown 支持的语法之外，NexT 借助 Hexo 提供的标签特性， 为您提供在书写文档时快速插入带特殊样式的内容。 4.常见问题NexT 使用中常见的问题。当您在使用中有疑问的时候，不妨先来这里看看。 或者在这里分享您在使用过程中碰到的问题。 GitHub —— 是一个面向开源及私有软件项目的托管平台gitHub因为只支持git作为唯一的版本库格式进行托管，故名gitHub。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 在GitHub进行分支就像在Myspace（或Facebook…）进行交友一样，在社会关系图的节点中不断的连线。 GitHub项目本身自然而然的也在GitHub上进行托管，只不过在一个私有的，公共视图不可见的库中。开源项目可以免费托管，但私有库则并不如此。Chris Wanstrath，GitHub的开发者之一，肯定了通过付费的私有库来在财务上支持免费库的托管这一计划。 是的，我们正是这么计划的。通过与客户的接洽，开发FamSpam，甚至是开发GitHub本身，GitHub的私有库已经被证明了物有所值。任何希望节省时间并希望和团队其它成员一样远离页面频繁转换之苦的人士都会从GitHub中获得他们真正想要的价值。 在GitHub，用户可以十分轻易地找到海量的开源代码。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2018%2F12%2F25%2Ftitle5%2F</url>
    <content type="text"><![CDATA[hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器1234hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 123hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的12hexo generate --deployhexo deploy --generate 12hexo deploy -ghexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模板12345hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHub 123hexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上123hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署1ERROR Deployer not found: git 解决方法 1npm install hexo-deployer-git --save 3.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuild12xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance 1npm install bcrypt 5. RSS不显示安装RSS插件1npm install hexo-generator-feed --save 开启RSS功能编辑hexo/_config.yml，添加如下代码： 1rss: /atom.xml #rss地址 默认即可 开启评论我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 1.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 2.复制到 themes\landscape\layout_partial\article.ejs 把 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 改为 1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（4）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle4%2F</url>
    <content type="text"><![CDATA[javascript面向对象中继承实现？面向对象的基本特征有：封闭、继承、多态。 在JavaScript中实现继承的方法： 原型链（prototype chaining） call()/apply() 混合方式(prototype和call()/apply()结合) 对象冒充 继承的方法如下： 1、prototype原型链方式： 1234567891011121314151617 function teacher(name)&#123; this.name = name;&#125;teacher.prototype.sayName = function()&#123; console.log("name is "+this.name);&#125;var teacher1 = new teacher("xiaoming");teacher1.sayName(); function student(name)&#123; this.name = name;&#125;student.prototype = new teacher()var student1 = new student("xiaolan");student1.sayName();// name is xiaoming// name is xiaolan 2、call()/apply()方法 1234567891011121314151617181920function teacher(name,age)&#123;this.name = name;this.age = age;this.sayhi = function()&#123;alert('name:'+name+", age:"+age);&#125;&#125;function student()&#123;var args = arguments;teacher.call(this,args[0],args[1]);// teacher.apply(this,arguments);&#125;var teacher1 = new teacher('xiaoming',23);teacher1.sayhi();var student1 = new student('xiaolan',12);student1.sayhi();// alert: name:xiaoming, age:23// alert: name:xiaolan, age:12 3、混合方法【prototype,call/apply】 12345678910111213141516171819202122function teacher(name,age)&#123;this.name = name;this.age = age;&#125;teacher.prototype.sayName = function()&#123;console.log('name:'+this.name);&#125;teacher.prototype.sayAge = function()&#123;console.log('age:'+this.age);&#125;function student()&#123;var args = arguments;teacher.call(this,args[0],args[1]);&#125;student.prototype = new teacher();var student1 = new student('xiaolin',23);student1.sayName();student1.sayAge();// name:xiaolin// age:23 4、对象冒充 123456789101112131415161718192021function Person(name,age)&#123;this.name = name;this.age = age;this.show = function()&#123;console.log(this.name+", "+this.age);&#125;&#125;function Student(name,age)&#123;this.student = Person; //将Person类的构造函数赋值给this.studentthis.student(name,age); //js中实际上是通过对象冒充来实现继承的delete this.student; //移除对Person的引用&#125;var s = new Student("小明",17);s.show();var p = new Person("小花",18);p.show();// 小明, 17// 小花, 18 javascript相关程序计算题1、判断一个字符串中出现次数最多的字符，统计这个次数123456789101112131415161718var str = 'asdfssaaasasasasaa';var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = '';for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125;&#125; console.log('出现次数最多的是:'+iIndex+'出现'+iMax+'次'); 结果如下：出现次数最多的是:a出现9次 JavaScript 数组(Array)对象1、Array相关的属性和方法这里只是做了相关的列举，具体的使用方法，请参考网址。 Array 对象属性constructor 返回对创建此对象的数组函数的引用。 length 设置或返回数组中元素的数目。 prototype 使您有能力向对象添加属性和方法。 Array 对象方法concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素。 shift() 删除并返回数组的第一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 2、编写一个方法 去掉一个数组的重复元素方法一： 12345678910var arr = [0,2,3,4,4,0,2];var obj = &#123;&#125;;var tmp = [];for(var i = 0 ;i&lt; arr.length;i++)&#123; if( !obj[arr[i]] )&#123; obj[arr[i]] = 1; tmp.push(arr[i]); &#125;&#125;console.log(tmp); 结果如下： [0, 2, 3, 4] 方法二： 12345678var arr = [2,3,4,4,5,2,3,6], arr2 = [];for(var i = 0;i&lt; arr.length;i++)&#123; if(arr2.indexOf(arr[i]) &lt; 0)&#123; arr2.push(arr[i]); &#125;&#125;console.log(arr2); 结果为：[2, 3, 4, 5, 6] 方法三： 12345var arr = [2,3,4,4,5,2,3,6];var arr2 = arr.filter(function(element,index,self)&#123;return self.indexOf(element) === index;&#125;);console.log(arr2); 结果为：[2, 3, 4, 5, 6]]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（3）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle3%2F</url>
    <content type="text"><![CDATA[如何理解闭包？1、定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 2、表现形式：使函数外部能够调用函数内部定义的变量。 3、实例如下： (1)、根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count 。 1234567891011var count=10; //全局作用域 标记为flag1function add()&#123; var count=0; //函数全局作用域 标记为flag2 return function()&#123; count+=1; //函数的内部作用域 alert(count); &#125;&#125;var s = add()s();//输出1s();//输出2 4、变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域分类：全局变量和局部变量。 特点： 1、函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。 2、函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 5、使用闭包的注意点 1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况： 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90. 2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。 实现方法：通过nginx代理； 注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。 (2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。 使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; "Content-Type": "text/html; charset=UTF-8", "Access-Control-Allow-Origin":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。 特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。 实例如下： 1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = "text/javascript"; _script.src = "http://localhost:8888/jsonp?callback=testjsonp"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。 谈谈垃圾回收机制方式及内存管理回收机制方式1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。 2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 3、实例如下： 123456789function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 4、垃圾回收策略：标记清除(较为常用)和引用计数。 标记清除： 定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数： 定义和用法：引用计数是跟踪记录每个值被引用的次数。 基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。 内存管理1、什么时候触发垃圾回收？ 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。 IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。 IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。 2、合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。 3、GC缺陷：(1)、停止响应其他操作； 4、GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC 开发过程中遇到的内存泄露情况，如何解决的？1、定义和用法： 内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。 2、内存泄露的几种情况: (1)、当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 实例如下: 123456789&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; document.getElementById("myDiv").innerHTML = "Processing..."; &#125;&lt;/script&gt; 解决方法如下： 12345678910&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; btn.onclick = null; document.getElementById("myDiv").innerHTML = "Processing..."; &#125;&lt;/script&gt; (2)、由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。实例如下： 123456function bindEvent()&#123; var obj=document.createElement("XXX"); obj.onclick=function()&#123; //Even if it's a empty function &#125;&#125; 解决方法如下： 1234567function bindEvent()&#123; var obj=document.createElement("XXX"); obj.onclick=function()&#123; //Even if it's a empty function &#125; obj=null;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（2）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle2%2F</url>
    <content type="text"><![CDATA[js 字符串操作函数我这里只是列举了常用的字符串函数，具体使用方法，请参考网址。 concat() – 将两个或多个字符的文本组合起来，返回一个新的字符串。 indexOf() – 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 。 charAt() – 返回指定位置的字符。 lastIndexOf() – 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 。 match() – 检查一个字符串是否匹配一个正则表达式。 substr() 函数 – 返回从string的startPos位置，长度为length的字符串 substring() – 返回字符串的一个子串。传入参数是起始位置和结束位置。 slice() – 提取字符串的一部分，并返回一个新字符串。 replace() – 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 search() – 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 split() – 通过将字符串划分成子串，将一个字符串做成一个字符串数组。 length – 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 toLowerCase() – 将整个字符串转成小写字母。 toUpperCase() – 将整个字符串转成大写字母。 怎样添加、移除、移动、复制、创建和查找节点？1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 写出3个使用this的典型应用（1）、在html元素事件属性中使用，如：1&lt;input type=”button” onclick=”showInfo(this);” value=”点击一下”/&gt; （2）、构造函数1234function Animal(name, color) &#123; this.name = name; this.color = color;&#125; （3）、input点击，获取值1234567&lt;input type="button" id="text" value="点击一下" /&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("text"); btn.onclick = function() &#123; alert(this.value); //此处的this是按钮元素 &#125;&lt;/script&gt; （4）、apply()/call()求数组最值12345var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(this, numbers); console.log(maxInNumbers); // 458var maxInNumbers = Math.max.call(this,5, 458 , 120 , -215); console.log(maxInNumbers); // 458 比较typeof与instanceof？相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。 (2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。 (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 实例演示： 12345a instanceof b?alert("true"):alert("false"); //a是b的实例？真:假var a = new Array(); alert(a instanceof Array); // truealert(a instanceof Object) // true 如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。 123function test()&#123;&#125;;var a = new test();alert(a instanceof test) // true 细节： (1)、如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。 1if (window instanceof Object)&#123; alert('Y')&#125; else &#123; alert('N');&#125; // 'N']]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（1）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle1%2F</url>
    <content type="text"><![CDATA[本篇收录了一些面试中经常会遇到的经典面试题以及自己面试过程中遇到的一些问题，并且都给出了我在网上收集的答案。马上就要过春节了，开年就是崭新的一年，相信很多的前端开发者会有一些跳槽的悸动，通过对本篇知识的整理以及经验的总结，希望能帮到更多的前端面试者。（如有错误或更好的答案，欢迎指正，水平有限，望各位不吝指教。） JavaScript:JavaScript中如何检测一个变量是一个String类型？请写出函数实现123typeof(obj) === "string"typeof obj === "string"obj.constructor === String 请用js去除字符串空格？方法一：使用replace正则匹配的方法去除所有空格: str = str.replace(/\s*/g,””); 去除两头空格: str = str.replace(/^\s|\s$/g,””); 去除左空格： str = str.replace( /^\s*/, “”); 去除右空格： str = str.replace(/(\s*$)/g, “”); str为要去除空格的字符串，实例如下： 123var str = " 23 23 ";var str2 = str.replace(/\s*/g,"");console.log(str2); // 2323 方法二：使用str.trim()方法str.trim()局限性：无法去除中间的空格，实例如下： 123var str = " xiao ming ";var str2 = str.trim();console.log(str2); //xiao ming 同理，str.trimLeft()，str.trimRight()分别用于去除字符串左右空格。 方法三：使用jquery,$.trim(str)方法$.trim(str)局限性：无法去除中间的空格，实例如下： 123var str = " xiao ming ";var str2 = $.trim(str)console.log(str2); // xiao ming 你如何获取浏览器URL中查询字符串中的参数？实例如下： 12345678910111213141516function showWindowHref()&#123; var sHref = window.location.href; var args = sHref.split('?'); if(args[0] == sHref)&#123; return ""; &#125; var arr = args[1].split('&amp;'); var obj = &#123;&#125;; for(var i = 0;i&lt; arr.length;i++)&#123; var arg = arr[i].split('='); obj[arg[0]] = arg[1]; &#125; return obj;&#125;var href = showWindowHref(); // objconsole.log(href['name']); // xiaoming]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
