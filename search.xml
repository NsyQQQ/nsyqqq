<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[本站的搭建过程]]></title>
    <url>%2F2018%2F12%2F26%2Ftitle6%2F</url>
    <content type="text"><![CDATA[Hexo —— 快速、简洁且高效的博客框架12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 1.超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 2.支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 3.一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 4.丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 Node.js —— 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 不是一个 JavaScript 框架，不同于CakePHP、Django、Rails。Node.js 更不是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 git —— 分布式版本控制系统Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. NexT —— Elegant Theme for Hexo (精于心，简于形)1.主题配置NexT 坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。 2.第三方服务集成使用 第三方服务 来扩展站点的功能， NexT 支持多种常见第三方服务。 评论系统来必力(https://www.livere.com)123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC80MTgyMS8xODM2Nw== 数据统计与分析百度统计(https://tongji.baidu.com/web/welcome/login)12# Baidu Analytics IDbaidu_analytics: 05b9e90829bd8b83641409c77e41d36a 阅读次数统计（LeanCloud)123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 0Bkl73pRei0NBwLm1JnzAagz-gzGzoHsz app_key: QjEOooUCUuj2kvBUlrlRP1gt 内容分享服务JiaThis(http://www.jiathis.com)123456# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https. jiathis: true ##uid: Get this uid from http://www.jiathis.com/ 搜索服务Local Search(https://github.com/flashlab/hexo-generator-search)12345678910111213141516$ npm install hexo-generator-searchdb --save# 搜索search: path: search.xml field: post format: html limit: 10000# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 3.内置标签除了 Markdown 支持的语法之外，NexT 借助 Hexo 提供的标签特性， 为您提供在书写文档时快速插入带特殊样式的内容。 4.常见问题NexT 使用中常见的问题。当您在使用中有疑问的时候，不妨先来这里看看。 或者在这里分享您在使用过程中碰到的问题。 GitHub —— 是一个面向开源及私有软件项目的托管平台gitHub因为只支持git作为唯一的版本库格式进行托管，故名gitHub。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。 如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。 GitHub可以托管各种git库，并提供一个web界面，但它与外国的SourceForge、Google Code或中国的coding的服务不同，GitHub的独特卖点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码玩家的MySpace。 在GitHub进行分支就像在Myspace（或Facebook…）进行交友一样，在社会关系图的节点中不断的连线。 GitHub项目本身自然而然的也在GitHub上进行托管，只不过在一个私有的，公共视图不可见的库中。开源项目可以免费托管，但私有库则并不如此。Chris Wanstrath，GitHub的开发者之一，肯定了通过付费的私有库来在财务上支持免费库的托管这一计划。 是的，我们正是这么计划的。通过与客户的接洽，开发FamSpam，甚至是开发GitHub本身，GitHub的私有库已经被证明了物有所值。任何希望节省时间并希望和团队其它成员一样远离页面频繁转换之苦的人士都会从GitHub中获得他们真正想要的价值。 在GitHub，用户可以十分轻易地找到海量的开源代码。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>git</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令笔记]]></title>
    <url>%2F2018%2F12%2F25%2Ftitle5%2F</url>
    <content type="text"><![CDATA[hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n "我的博客" == hexo new "我的博客" #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 服务器1234hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 123hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的12hexo generate --deployhexo deploy --generate 12hexo deploy -ghexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模板12345hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHub 123hexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上123hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署1ERROR Deployer not found: git 解决方法 1npm install hexo-deployer-git --save 3.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuild12xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance 1npm install bcrypt 5. RSS不显示安装RSS插件1npm install hexo-generator-feed --save 开启RSS功能编辑hexo/_config.yml，添加如下代码： 1rss: /atom.xml #rss地址 默认即可 开启评论我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 1.在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 2.复制到 themes\landscape\layout_partial\article.ejs 把 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt; 改为 1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（4）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle4%2F</url>
    <content type="text"><![CDATA[javascript面向对象中继承实现？面向对象的基本特征有：封闭、继承、多态。 在JavaScript中实现继承的方法： 原型链（prototype chaining） call()/apply() 混合方式(prototype和call()/apply()结合) 对象冒充 继承的方法如下： 1、prototype原型链方式： 1234567891011121314151617 function teacher(name)&#123; this.name = name;&#125;teacher.prototype.sayName = function()&#123; console.log("name is "+this.name);&#125;var teacher1 = new teacher("xiaoming");teacher1.sayName(); function student(name)&#123; this.name = name;&#125;student.prototype = new teacher()var student1 = new student("xiaolan");student1.sayName();// name is xiaoming// name is xiaolan 2、call()/apply()方法 1234567891011121314151617181920function teacher(name,age)&#123;this.name = name;this.age = age;this.sayhi = function()&#123;alert('name:'+name+", age:"+age);&#125;&#125;function student()&#123;var args = arguments;teacher.call(this,args[0],args[1]);// teacher.apply(this,arguments);&#125;var teacher1 = new teacher('xiaoming',23);teacher1.sayhi();var student1 = new student('xiaolan',12);student1.sayhi();// alert: name:xiaoming, age:23// alert: name:xiaolan, age:12 3、混合方法【prototype,call/apply】 12345678910111213141516171819202122function teacher(name,age)&#123;this.name = name;this.age = age;&#125;teacher.prototype.sayName = function()&#123;console.log('name:'+this.name);&#125;teacher.prototype.sayAge = function()&#123;console.log('age:'+this.age);&#125;function student()&#123;var args = arguments;teacher.call(this,args[0],args[1]);&#125;student.prototype = new teacher();var student1 = new student('xiaolin',23);student1.sayName();student1.sayAge();// name:xiaolin// age:23 4、对象冒充 123456789101112131415161718192021function Person(name,age)&#123;this.name = name;this.age = age;this.show = function()&#123;console.log(this.name+", "+this.age);&#125;&#125;function Student(name,age)&#123;this.student = Person; //将Person类的构造函数赋值给this.studentthis.student(name,age); //js中实际上是通过对象冒充来实现继承的delete this.student; //移除对Person的引用&#125;var s = new Student("小明",17);s.show();var p = new Person("小花",18);p.show();// 小明, 17// 小花, 18 javascript相关程序计算题1、判断一个字符串中出现次数最多的字符，统计这个次数123456789101112131415161718var str = 'asdfssaaasasasasaa';var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = '';for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125;&#125; console.log('出现次数最多的是:'+iIndex+'出现'+iMax+'次'); 结果如下：出现次数最多的是:a出现9次 JavaScript 数组(Array)对象1、Array相关的属性和方法这里只是做了相关的列举，具体的使用方法，请参考网址。 Array 对象属性constructor 返回对创建此对象的数组函数的引用。 length 设置或返回数组中元素的数目。 prototype 使您有能力向对象添加属性和方法。 Array 对象方法concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素。 shift() 删除并返回数组的第一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 valueOf() 返回数组对象的原始值 2、编写一个方法 去掉一个数组的重复元素方法一： 12345678910var arr = [0,2,3,4,4,0,2];var obj = &#123;&#125;;var tmp = [];for(var i = 0 ;i&lt; arr.length;i++)&#123; if( !obj[arr[i]] )&#123; obj[arr[i]] = 1; tmp.push(arr[i]); &#125;&#125;console.log(tmp); 结果如下： [0, 2, 3, 4] 方法二： 12345678var arr = [2,3,4,4,5,2,3,6], arr2 = [];for(var i = 0;i&lt; arr.length;i++)&#123; if(arr2.indexOf(arr[i]) &lt; 0)&#123; arr2.push(arr[i]); &#125;&#125;console.log(arr2); 结果为：[2, 3, 4, 5, 6] 方法三： 12345var arr = [2,3,4,4,5,2,3,6];var arr2 = arr.filter(function(element,index,self)&#123;return self.indexOf(element) === index;&#125;);console.log(arr2); 结果为：[2, 3, 4, 5, 6]]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（3）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle3%2F</url>
    <content type="text"><![CDATA[如何理解闭包？1、定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。 2、表现形式：使函数外部能够调用函数内部定义的变量。 3、实例如下： (1)、根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count 。 1234567891011var count=10; //全局作用域 标记为flag1function add()&#123; var count=0; //函数全局作用域 标记为flag2 return function()&#123; count+=1; //函数的内部作用域 alert(count); &#125;&#125;var s = add()s();//输出1s();//输出2 4、变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域分类：全局变量和局部变量。 特点： 1、函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。 2、函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 5、使用闭包的注意点 1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 什么是跨域？跨域请求资源的方法有哪些？1、什么是跨域？由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况： 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90. 2、跨域请求资源的方法：(1)、porxy代理定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。 实现方法：通过nginx代理； 注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。 (2)、CORS 【Cross-Origin Resource Sharing】定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。 使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下： 123456res.writeHead(200, &#123; "Content-Type": "text/html; charset=UTF-8", "Access-Control-Allow-Origin":'http://localhost', 'Access-Control-Allow-Methods': 'GET, POST, OPTIONS', 'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'&#125;); (3)、jsonp定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。 特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。 实例如下： 1234567891011&lt;script&gt; function testjsonp(data) &#123; console.log(data.name); // 获取返回的结果 &#125;&lt;/script&gt;&lt;script&gt; var _script = document.createElement('script'); _script.type = "text/javascript"; _script.src = "http://localhost:8888/jsonp?callback=testjsonp"; document.head.appendChild(_script);&lt;/script&gt; 缺点： 1、这种方式无法发送post请求（这里） 2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。 谈谈垃圾回收机制方式及内存管理回收机制方式1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。 2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 3、实例如下： 123456789function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 4、垃圾回收策略：标记清除(较为常用)和引用计数。 标记清除： 定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数： 定义和用法：引用计数是跟踪记录每个值被引用的次数。 基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。 内存管理1、什么时候触发垃圾回收？ 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。 IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。 IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。 2、合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。 3、GC缺陷：(1)、停止响应其他操作； 4、GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC 开发过程中遇到的内存泄露情况，如何解决的？1、定义和用法： 内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。 2、内存泄露的几种情况: (1)、当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 实例如下: 123456789&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; document.getElementById("myDiv").innerHTML = "Processing..."; &#125;&lt;/script&gt; 解决方法如下： 12345678910&lt;div id="myDiv"&gt; &lt;input type="button" value="Click me" id="myBtn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("myBtn"); btn.onclick = function()&#123; btn.onclick = null; document.getElementById("myDiv").innerHTML = "Processing..."; &#125;&lt;/script&gt; (2)、由于是函数内定义函数，并且内部函数–事件回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。实例如下： 123456function bindEvent()&#123; var obj=document.createElement("XXX"); obj.onclick=function()&#123; //Even if it's a empty function &#125;&#125; 解决方法如下： 1234567function bindEvent()&#123; var obj=document.createElement("XXX"); obj.onclick=function()&#123; //Even if it's a empty function &#125; obj=null;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（2）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle2%2F</url>
    <content type="text"><![CDATA[js 字符串操作函数我这里只是列举了常用的字符串函数，具体使用方法，请参考网址。 concat() – 将两个或多个字符的文本组合起来，返回一个新的字符串。 indexOf() – 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 。 charAt() – 返回指定位置的字符。 lastIndexOf() – 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 。 match() – 检查一个字符串是否匹配一个正则表达式。 substr() 函数 – 返回从string的startPos位置，长度为length的字符串 substring() – 返回字符串的一个子串。传入参数是起始位置和结束位置。 slice() – 提取字符串的一部分，并返回一个新字符串。 replace() – 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。 search() – 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。 split() – 通过将字符串划分成子串，将一个字符串做成一个字符串数组。 length – 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。 toLowerCase() – 将整个字符串转成小写字母。 toUpperCase() – 将整个字符串转成大写字母。 怎样添加、移除、移动、复制、创建和查找节点？1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 写出3个使用this的典型应用（1）、在html元素事件属性中使用，如：1&lt;input type=”button” onclick=”showInfo(this);” value=”点击一下”/&gt; （2）、构造函数1234function Animal(name, color) &#123; this.name = name; this.color = color;&#125; （3）、input点击，获取值1234567&lt;input type="button" id="text" value="点击一下" /&gt;&lt;script type="text/javascript"&gt; var btn = document.getElementById("text"); btn.onclick = function() &#123; alert(this.value); //此处的this是按钮元素 &#125;&lt;/script&gt; （4）、apply()/call()求数组最值12345var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(this, numbers); console.log(maxInNumbers); // 458var maxInNumbers = Math.max.call(this,5, 458 , 120 , -215); console.log(maxInNumbers); // 458 比较typeof与instanceof？相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。 (2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。 (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 实例演示： 12345a instanceof b?alert("true"):alert("false"); //a是b的实例？真:假var a = new Array(); alert(a instanceof Array); // truealert(a instanceof Object) // true 如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。 123function test()&#123;&#125;;var a = new test();alert(a instanceof test) // true 细节： (1)、如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。 1if (window instanceof Object)&#123; alert('Y')&#125; else &#123; alert('N');&#125; // 'N']]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018最新Web前端经典面试试题及答案（1）]]></title>
    <url>%2F2018%2F12%2F24%2Ftitle1%2F</url>
    <content type="text"><![CDATA[本篇收录了一些面试中经常会遇到的经典面试题以及自己面试过程中遇到的一些问题，并且都给出了我在网上收集的答案。马上就要过春节了，开年就是崭新的一年，相信很多的前端开发者会有一些跳槽的悸动，通过对本篇知识的整理以及经验的总结，希望能帮到更多的前端面试者。（如有错误或更好的答案，欢迎指正，水平有限，望各位不吝指教。） JavaScript:JavaScript中如何检测一个变量是一个String类型？请写出函数实现123typeof(obj) === "string"typeof obj === "string"obj.constructor === String 请用js去除字符串空格？方法一：使用replace正则匹配的方法去除所有空格: str = str.replace(/\s*/g,””); 去除两头空格: str = str.replace(/^\s|\s$/g,””); 去除左空格： str = str.replace( /^\s*/, “”); 去除右空格： str = str.replace(/(\s*$)/g, “”); str为要去除空格的字符串，实例如下： 123var str = " 23 23 ";var str2 = str.replace(/\s*/g,"");console.log(str2); // 2323 方法二：使用str.trim()方法str.trim()局限性：无法去除中间的空格，实例如下： 123var str = " xiao ming ";var str2 = str.trim();console.log(str2); //xiao ming 同理，str.trimLeft()，str.trimRight()分别用于去除字符串左右空格。 方法三：使用jquery,$.trim(str)方法$.trim(str)局限性：无法去除中间的空格，实例如下： 123var str = " xiao ming ";var str2 = $.trim(str)console.log(str2); // xiao ming 你如何获取浏览器URL中查询字符串中的参数？实例如下： 12345678910111213141516function showWindowHref()&#123; var sHref = window.location.href; var args = sHref.split('?'); if(args[0] == sHref)&#123; return ""; &#125; var arr = args[1].split('&amp;'); var obj = &#123;&#125;; for(var i = 0;i&lt; arr.length;i++)&#123; var arg = arr[i].split('='); obj[arg[0]] = arg[1]; &#125; return obj;&#125;var href = showWindowHref(); // objconsole.log(href['name']); // xiaoming]]></content>
      <categories>
        <category>学习</category>
        <category>面试题</category>
        <category>Web前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
